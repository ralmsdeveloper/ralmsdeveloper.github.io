---
title: "Introdução ao Channel - Parte 1"
comments: true
excerpt_separator: "Ler mais"
toc: true
toc_label: "Tópicos"
categories:
  - dotnet
  - channel
  - performance
  - distributed
header:
  teaser: /assets/images/channel/channel-top.png
  caption: "www.ralms.net"
---

![01]({{site.url}}{{site.baseurl}}/assets/images/channel/channel-top.png)
<hr /> 
<div class="notice--warning" style="background-color:#f8ffc4">
Neste artigo abordaremos um dos recursos do .NET que nos fornece a capacidade de distribuir o processamento de dados em nossas aplicações por meio de um canal, usando o padrão: producer-consumer, o qual abordaremos logo mais.
</div> 

## Introdução
<div style="text-align: justify;">
&nbsp;&nbsp;&nbsp;&nbsp;Constantemente estamos a procura de melhor performance e escalabilidade para nossas aplicações,  isso tudo é maravilhoso para o momento que vivemos da era da computação em nuvem, vários provedores de serviços se especializaram nisso, um exemplo são as grandes empresas de tecnologia, como: Microsoft, Amazon, Google, IBM, Red Hat, entre outras, e graças a nuvem é possível ter recursos computacionais fantásticos, produtos que são capazes de resolver basicamente qualquer problema, procurando entregar mais valor para o consumidor em um tempo menor e com extrema segurança, mas não se engane, procurar estratégias melhores para seu software é um dever seu como um bom profissional, isso faz parte de todo ciclo de desenvolvimento de um bom sistema.
<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;O recurso que abordaremos faz bom uso de concorrência e assincronismo, sendo assim existe a necessidade de esclarecer alguns pontos antes de seguir com o artigo, existe uma grande confusão por parte de muitas pessoas sobre o que é concorrência, simultaneidade e paralelismo, o problema é que concorrência é muito confundido com paralelismo, com a concorrência até conseguimos lidar inúmeras coisas ao mesmo tempo em um único processador, mas isso de forma alguma quer dizer que está sendo executado de forma paralela.
</div>
## Concorrência
<div style="text-align: justify;">
 &nbsp;&nbsp;&nbsp;&nbsp;Faz com que o programa seja capaz de lidar com várias coisas ao mesmo tempo, na vida real imaginemos a seguinte situação, você está indo ao banco fazer um depósito, então dois amigos chegam até você e perguntam se você pode fazer um depósito por eles, você fala que sim e ao chegar ao banco encontra três terminais livres.
</div>
![01]({{site.url}}{{site.baseurl}}/assets/images/channel/imagem01.png)
<div style="text-align: justify;">
&nbsp;&nbsp;&nbsp;&nbsp;Então você tenta iniciar o procedimento de depósito nos três terminais ao mesmo tempo, e corre de um lado para o outro freneticamente, fica claro que você está concorrendo tempo com você mesmo, separando uma certa quantidade de tempo para ir de um terminal para o outro e tentar continuar de onde parou sua última iteração com o terminal, é assim que funciona a concorrência, estamos lidando com algumas coisas ao mesmo tempo, mas não executando paralelamente ao mesmo tempo.
<br /><br />
Olhando para CPU é exatamente isso que ocorre quando temos apenas uma unidade de processamento (1 Core), convivemos com a ilusão da simultaneidade, mas o que o processador faz é  apenas compartilhar um pequeno espaço de tempo entre os procedimentos para executar de forma concorrente, passando a sensação que tudo foi executado ao mesmo tempo.
</div>
## Paralelismo
<div style="text-align: justify;">
&nbsp;&nbsp;&nbsp;&nbsp;Pegando o exemplo apresentado anteriormente e alterando o cenário para o qual  seus amigos juntamente com você foram ao banco e encontraram três terminais livres, cada um se dirige a um terminal específico e inicia o processamento de forma isolada e ao mesmo tempo que você.
</div>
![01]({{site.url}}{{site.baseurl}}/assets/images/channel/imagem02.png)
<div style="text-align: justify;">
Nesse exemplo fica explicitamente nítido um padrão de execução usando paralelismo, cada um consegue atuar isoladamente sem saber exatamente o que o outro está fazendo, o paralelismo é possível apenas quando temos mais de um núcleo de CPU, os sistemas operacionais sempre se comportaram de forma excelente, mesmo com limitações existente, fazia o bom uso da concorrência, mas com surgimento evolução dos processadores isso muda o jogo, agora podemos ser capazes de executar tarefas verdadeiramente paralelas, e cada núcleo de CPU se beneficiando ainda mais com o poder da concorrência e simultaneidade.
</div>

## Quebrando teorias errôneas e falácias
<div style="text-align: justify;">
Não é porque podemos disparar inúmeras threads que iremos automaticamente ter paralelismo, isso não é uma verdade, multithreading  só existe com paralelismo, e paralelismo real só existe com mais de um core de CPU, então não se iluda, disparar muitas threads você tem concorrência, agendamentos de execução de procedimentos, fornecendo uma sensação simultaneidade.
</div>
![01]({{site.url}}{{site.baseurl}}/assets/images/channel/imagem03.png)
<div style="text-align: justify;">
Em uma próxima oportunidade irei escrever um artigo falando sobre processamento síncrono, assíncrono, concorrência, multithreading e paralelismo, focaremos aqui no recurso channel do dotnet, mas não poderia seguir sem passar os conceitos básicos como apresentado logo acima.
</div>
## O que é Channel?
<div style="text-align: justify;">
Resumidamente o channel(<i>ou canal em português</i>) é uma implementação feita Microsoft no <b>dotnet core</b> e que está acessível por meio do namespace (<i>System.Threading.Channels</i>), fornece a possibilidade de distribuir o processamento de dados em nossas aplicações, fazendo um excelente uso de <b>concorrência e paralelismo</b>, a ideia básica é que por meio de um canal, possamos produzir algo para um consumidor recuperar e processar, com isso podemos escalar algumas tarefas para melhor a performance, logo temos um padrão: <b><i>“producer-consumer”</i></b>. 
</div>
![Channel]({{site.url}}{{site.baseurl}}/assets/images/channel/imagem-channel.png)
<div style="text-align: justify;">
Podemos usar esse padrão para resolver alguns problemas inclusive de performance em nossas aplicações, produzir e consumir está presente em muitas das coisas na vida real, como por exemplo uma professora em uma sala de aula escrevendo em um quadro, e seus alunos consumindo suas informações, um garçom fazendo nosso pedido em um restaurante e enviando para a cozinha onde diversos profissionais realizarão tarefas com base no pedido enviado, na computação não é nada diferente, temos diversos problemas que podemos resolver com padrões e implementações feitas em frameworks para acelerar a produtividade. O <b>Channel</b> surgiu exatamente para isso.
</div>
## Cenário
<div style="text-align: justify;">
Vamos pegar um exemplo hipotético para começar a exercitar e alinhar nossos pensamentos de como realmente podemos usar o recurso <b>Channels</b> para nos ajudar a otimizar alguns processos, atender demandas específicas que são críticas e precisam ser processadas em uma janela pequena de tempo, o cenário é o seguinte: 
</div>
- Você tem um arquivo csv com 1000 (mil produtos)
- Precisa extrair as linhas desse arquivo
- Montar um objeto e serializar
- Enviar para um broker (SQS, Google Pub/Sub, Kafka, RabbitMQ)

## Amostras de códigos
Primeiramente vamos construir nossa classe <b>Produto</b>:
```csharp
public class Produto
{
    public string SKU { get; set; }
    public string Descricao { get; set; }
    public decimal Preco { get; set; }
    public int Estoque { get; set; }
}
```
<br />
## Twitter
<div class="notice--info">
 Fico por aqui! 😄 <br />
 twitter: <a alt="" href="https://twitter.com/RalmsDeveloper">@ralmsdeveloper</a><br />
 linkedin: <a alt="" href="https://www.linkedin.com/in/ralmsdeveloper/">@ralmsdeveloper</a><br />
</div> 

<br>
