---
title: "Introdução ao Channel - Parte 1"
comments: true
excerpt_separator: "Ler mais"
toc: true
toc_label: "Tópicos"
categories:
  - dotnet
  - channel
  - performance
  - distributed
header:
  teaser: /assets/images/channel/channel-top.png
  caption: "www.ralms.net"
---

![01]({{site.url}}{{site.baseurl}}/assets/images/channel/channel-top.png)
<hr /> 
<div class="notice--warning" style="background-color:#f8ffc4">
Neste artigo abordaremos um dos recursos do .NET que nos fornece a capacidade de distribuir o processamento de dados em nossas aplicações por meio de um canal, usando o padrão: producer-consumer, o qual abordaremos logo mais.
</div> 

## Introdução
<div style="text-align: justify;">
&nbsp;&nbsp;&nbsp;&nbsp;Constantemente estamos a procura de melhor performance e escalabilidade para nossas aplicações,  isso tudo é maravilhoso para o momento que vivemos da era da computação em nuvem, vários provedores de serviços se especializaram nisso, um exemplo são as grandes empresas de tecnologia, como: Microsoft, Amazon, Google, IBM, Red Hat, entre outras, e graças a nuvem é possível ter recursos computacionais fantásticos, produtos que são capazes de resolver basicamente qualquer problema, procurando entregar mais valor para o consumidor em um tempo menor e com extrema segurança, mas não se engane, procurar estratégias melhores para seu software é um dever seu como um bom profissional, isso faz parte de todo ciclo de desenvolvimento de um bom sistema.
<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;O recurso que abordaremos faz bom uso de concorrência e assincronismo, sendo assim existe a necessidade de esclarecer alguns pontos antes de seguir com o artigo, existe uma grande confusão por parte de muitas pessoas sobre o que é concorrência, simultaneidade e paralelismo, o problema é que concorrência é muito confundido com paralelismo, com a concorrência até conseguimos lidar inúmeras coisas ao mesmo tempo em um único processador, mas isso de forma alguma quer dizer que está sendo executado de forma paralela.
</div>
## Concorrência
<div style="text-align: justify;">
 &nbsp;&nbsp;&nbsp;&nbsp;Faz com que o programa seja capaz de lidar com várias coisas ao mesmo tempo, na vida real imaginemos a seguinte situação, você está indo ao banco fazer um depósito, então dois amigos chegam até você e perguntam se você pode fazer um depósito por eles, você fala que sim e ao chegar ao banco encontra três terminais livres.
</div>
![01]({{site.url}}{{site.baseurl}}/assets/images/channel/imagem01.png)
<div style="text-align: justify;">
&nbsp;&nbsp;&nbsp;&nbsp;Então você tenta iniciar o procedimento de depósito nos três terminais ao mesmo tempo, e corre de um lado para o outro freneticamente, fica claro que você está concorrendo tempo com você mesmo, separando uma certa quantidade de tempo para ir de um terminal para o outro e tentar continuar de onde parou sua última iteração com o terminal, é assim que funciona a concorrência, estamos lidando com algumas coisas ao mesmo tempo, mas não executando paralelamente ao mesmo tempo.
<br /><br />
Olhando para CPU é exatamente isso que ocorre quando temos apenas uma unidade de processamento (1 Core), convivemos com a ilusão da simultaneidade, mas o que o processador faz é  apenas compartilhar um pequeno espaço de tempo entre os procedimentos para executar de forma concorrente, passando a sensação que tudo foi executado ao mesmo tempo.
</div>
## Paralelismo
<div style="text-align: justify;">
&nbsp;&nbsp;&nbsp;&nbsp;Pegando o exemplo apresentado anteriormente e alterando o cenário para o qual  seus amigos juntamente com você foram ao banco e encontraram três terminais livres, cada um se dirige a um terminal específico e inicia o processamento de forma isolada e ao mesmo tempo que você.
</div>
![01]({{site.url}}{{site.baseurl}}/assets/images/channel/imagem02.png)
<div style="text-align: justify;">
Nesse exemplo fica explicitamente nítido um padrão de execução usando paralelismo, cada um consegue atuar isoladamente sem saber exatamente o que o outro está fazendo, o paralelismo é possível apenas quando temos mais de um núcleo de CPU, os sistemas operacionais sempre se comportaram de forma excelente, mesmo com limitações existente, fazia o bom uso da concorrência, mas com surgimento evolução dos processadores isso muda o jogo, agora podemos ser capazes de executar tarefas verdadeiramente paralelas, e cada núcleo de CPU se beneficiando ainda mais com o poder da concorrência e simultaneidade.
</div>

## Quebrando teorias errôneas e falácias
<div style="text-align: justify;">
Não é porque podemos disparar inúmeras threads que iremos automaticamente ter paralelismo, isso não é uma verdade, multithreading  só existe com paralelismo, e paralelismo real só existe com mais de um core de CPU, então não se iluda, disparar muitas threads você tem concorrência, agendamentos de execução de procedimentos, fornecendo uma sensação simultaneidade.
</div>
![01]({{site.url}}{{site.baseurl}}/assets/images/channel/imagem03.png)
<div style="text-align: justify;">
Em uma próxima oportunidade irei escrever um artigo falando sobre processamento síncrono, assíncrono, concorrência, multithreading e paralelismo, focaremos aqui no recurso channel do dotnet, mas não poderia seguir sem passar os conceitos básicos como apresentado logo acima.
</div>
## O que é Channel?
<div style="text-align: justify;">
Resumidamente o channel(<i>ou canal em português</i>) é uma implementação feita Microsoft no <b>dotnet core</b> e que está acessível por meio do namespace (<i>System.Threading.Channels</i>), fornece a possibilidade de distribuir o processamento de dados em nossas aplicações, fazendo um excelente uso de <b>concorrência e paralelismo</b>, a ideia básica é que por meio de um canal, possamos produzir algo para um consumidor recuperar e processar, com isso podemos escalar algumas tarefas para melhor a performance, logo temos um padrão: <b><i>“producer-consumer”</i></b>. 
</div>
![Channel]({{site.url}}{{site.baseurl}}/assets/images/channel/imagem-channel.png)
<div style="text-align: justify;">
Podemos usar esse padrão para resolver alguns problemas inclusive de performance em nossas aplicações, produzir e consumir está presente em muitas das coisas na vida real, como por exemplo uma professora em uma sala de aula escrevendo em um quadro, e seus alunos consumindo suas informações, um garçom fazendo nosso pedido em um restaurante e enviando para a cozinha onde diversos profissionais realizarão tarefas com base no pedido enviado, na computação não é nada diferente, temos diversos problemas que podemos resolver com padrões e implementações feitas em frameworks para acelerar a produtividade. O <b>Channel</b> surgiu exatamente para isso.
<br /> 
`Channel<T>` é uma classe abstrata genérica, e para instanciar precisamos usar alguns métodos da classe estática <b>Channel</b>, irei abordar apenas dois deles, na continuação deste artigo iremos fazer um deep-dive melhor, sendo assim os métodos básicos são:<br />
`CreateBounded<T>(int capacity):`<br />
Cria um canal delimitando a capacidade de objetos que podem ser alocados.<br />
`CreateUnbounded<T>():`<br />
Cria um canal sem limitar a capacidade de objetos que podem ser alocados, ao usar método deve-se tomar muito cuidado, sabemos que recursos da máquina não são infinitos, com isso você pode sobrecarregar a memória, mas falaremos mais sobre isso na continuação deste artigo.
<br /><br />

</div>
## Cenário
<div style="text-align: justify;">
Vamos pegar um exemplo hipotético para começar a exercitar e alinhar nossos pensamentos de como realmente podemos usar o recurso <b>Channels</b> para nos ajudar a otimizar alguns processos, atender demandas específicas que são críticas e precisam ser processadas em uma janela pequena de tempo, o cenário é o seguinte: 
</div>
- Você tem um arquivo csv com 1000 (mil produtos)
- Precisa extrair as linhas desse arquivo
- Montar um objeto e serializar
- Enviar para um broker (SQS, Google Pub/Sub, Kafka, RabbitMQ)

## Amostras de códigos
Primeiramente vamos construir nossa classe <b>Produto</b>:
```csharp
public class Produto
{
    public string SKU { get; set; }
    public string Descricao { get; set; }
    public decimal Preco { get; set; }
    public int Estoque { get; set; }
}
```
## Broker Fake
Classe para simular o comportamento de envio uma mensagem para um serviço de mensageria, com tempo de resposta de 10 milissegundos:
```csharp
public class BrokerFake
{
    public static async ValueTask SendAsync<T>(T data)
    {
        var message = JsonSerializer.Serialize(data);

        // Simular latência de 10 milissegundos
        await Task.Delay(TimeSpan.FromMilliseconds(10));
    }
} 
```    
## Implementação de uso do Channel
Classe com métodos de produzir e consumir dados, falaremos logo mais sobre ela:
```csharp
public class ChannelTest<T>
{
    private readonly Channel<T> _channel;
    private bool _runningConsummer;
    private bool _stopRequested;

    public ChannelTest()
    {
        _channel = Channel.CreateBounded<T>(1000);
    }

    public async ValueTask Enqueue(T data) 
        => await _channel.Writer.WriteAsync(data).ConfigureAwait(false);

    public async Task Consumer()
    {
        while (true)
        {
            if(_stopRequested && _channel.Reader.Count == 0)
            {
                break;
            }

            if(_channel.Reader.Count == 0)
            {
                await Task.Delay(10);

                continue;
            }

            if (_channel.Reader.TryRead(out var item))
            {
                await BrokerFake.SendAsync(item);
            }
        }
    }

    public void StartConsumers()
    {
        Task.Run(() =>
        {
            var tasks = new Task[6];

            for (int i = 0; i < tasks.Length; i++)
            {
                tasks[i] = Consumer();
            }

            _runningConsummer = true;

            Task.WaitAll(tasks);

            _runningConsummer = false;
        });
    }

    public void Complete()
    {
        _stopRequested = true;

        while (_runningConsummer) 
        { 
            Task.Delay(10).Wait(); 
        };
    }
}
```    

## Teste de performance
Classe com métodos para executar testes de performance:
```csharp
[MemoryDiagnoser]
public class Performance
{
    private static IEnumerable<Produto> GetProdutos()
    {
        var produtos = Enumerable.Range(1, 1000)
            .Select(p => new Produto
            {
                SKU = Guid.NewGuid().ToString("N"),
                Descricao = $"Produto {p}",
                Preco = (p * 1.1m),
                Estoque = p
            });

        return produtos;
    }

    [Benchmark]
    public async ValueTask SemChannel()
    {
        foreach (var produto in GetProdutos())
        {
            await BrokerFake.SendAsync(produto);
        }
    }

    [Benchmark]
    public async ValueTask ComChannel()
    {
        var channel = new ChannelTest<Produto>();
        channel.StartConsumers();

        foreach (var produto in GetProdutos())
        {
            await channel.Enqueue(produto);
        }

        channel.Complete();
    }
}
``` 

## Benchmark

<pre>
BenchmarkDotNet=v0.13.0, OS=Windows 10.0.22000
Intel Core i7-7500U CPU 2.70GHz (Kaby Lake), 1 CPU, 4 logical and 2 physical cores
.NET SDK=6.0.100-preview.6.21355.2
  [Host]     : .NET 5.0.8 (5.0.821.31504), X64 RyuJIT
  DefaultJob : .NET 5.0.8 (5.0.821.31504), X64 RyuJIT


|     Method |          Mean |      Error |     StdDev |        Median |
|----------- |--------------:|-----------:|-----------:|--------------:|
| SemChannel | 15,945.549 ms | 31.3865 ms | 27.8233 ms | 15,941.479 ms |
| ComChannel |      1.974 ms |  0.2007 ms |  0.5726 ms |      2.209 ms |

</pre>
<br />
## Twitter
<div class="notice--info">
 Fico por aqui! 😄 <br />
 twitter: <a alt="" href="https://twitter.com/RalmsDeveloper">@ralmsdeveloper</a><br />
 linkedin: <a alt="" href="https://www.linkedin.com/in/ralmsdeveloper/">@ralmsdeveloper</a><br />
</div> 

<br>
